## Python 装饰器 (decorator) @ 用法

参考：[python装饰器简介---这一篇也许就够了](https://blog.csdn.net/u010358168/article/details/77773199)

其中解释的比较好，如下

### 装饰器引入

先看代码

```python
def w1(func):
    def inner():
        print('...验证权限...')
        func()

    return inner


@w1
def f1():
    print('f1 called')


@w1
def f2():
    print('f2 called')


f1()
f2()
```

输出结果为

```python
...验证权限...
f1 called
...验证权限...
f2 called
```

可以通过代码及输出看到，在调用 f1 f2 函数时，成功进行了权限验证，那么是怎么做到的呢？其实这里就使用到了装饰器，通过定义一个闭包函数 w1，在我们调用函数上通过关键词 @w1，这样就对 f1 f2 函数完成了装饰。



### 装饰器原理

首先，开看我们的装饰器函数 `w1`，该函数接收一个参数 `func`，其实就是接收一个方法名，`w1` 内部又定义一个函数 `inner`，在 `inner` 函数中增加权限校验，并在验证完权限后调用传进来的参数 `func`，同时 `w1` 的返回值为内部函数 `inner`，其实就是一个闭包函数。

然后，再来看一下，在 `f1`上增加 `@w1`，那这是什么意思呢？当 python 解释器执行到这句话的时候，会去调用 `w1` 函数，同时将被装饰的函数名作为参数传入 (此时为 `f1`)，根据闭包一文分析，在执行 `w1` 函数的时候，此时直接把 `inner` 函数返回了，同时把它赋值给 `f1`，**此时的 `f1` 已经不是未加装饰时的 `f1` 了，而是指向了 `w1.inner` 函数地址**。

接下来，**在调用 `f1()` 的时候，其实调用的是 `w1.inner` 函数**，那么此时就会先执行权限验证，然后再调用原来的 `f1()`，该处的 `f1` 就是通过装饰传进来的参数 `f1`。

这样下来，就完成了对 `f1` 的装饰，实现了权限验证。



### 装饰器知识点

#### 执行时机

了解了装饰器的原理后，那么它的执行时机是什么样呢，接下来就来看一下。 先看代码

```python
def w1(fun):
    print('...装饰器开始装饰...')

    def inner():
        print('...验证权限...')
        fun()

    return inner


@w1
def test():
    print('test')

test()
```

输出结果为

```python
...装饰器开始装饰...
...验证权限...
test
```

